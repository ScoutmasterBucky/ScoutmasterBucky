var W=Object.defineProperty;var j=(m,r,u)=>r in m?W(m,r,{enumerable:!0,configurable:!0,writable:!0,value:u}):m[r]=u;var R=(m,r,u)=>j(m,typeof r!="symbol"?r+"":r,u);import{d as V,l as y,p as B,b as d,o as p,e,F as M,i as N,t as C,f as O,q as F,v as P,s as q,w as E,g as H,k as $,x as D,u as G}from"./vendor-vue.BBdgvs9q.js";import{_ as z}from"./vite.DlAUqK2U.js";const L=V({__name:"GroupOMaticStep4",props:{best:{}},setup(m){const r=y([]),u=()=>{r.value=Object.keys(m.best[0][0][0])};return u(),B(()=>m.best,u),(l,c)=>(p(),d(M,null,[c[0]||(c[0]=e("h2",null,"Group Results",-1)),(p(!0),d(M,null,N(l.best,(i,s)=>(p(),d("div",null,[e("h3",null,"Session "+C(s+1),1),(p(!0),d(M,null,N(i,(S,h)=>(p(),d("div",null,[e("p",null,"Group "+C(h+1),1),e("table",null,[e("tr",null,[(p(!0),d(M,null,N(r.value,n=>(p(),d("th",null,C(n),1))),256))]),(p(!0),d(M,null,N(S,n=>(p(),d("tr",null,[(p(!0),d(M,null,N(r.value,v=>(p(),d("td",null,C(n[v]),1))),256))]))),256))])]))),256))]))),256))],64))}}),Q=V({__name:"GroupOMaticStep3",props:{data:{},config:{}},emits:["best"],setup(m,{emit:r}){const u=r,l=y(!1),c=()=>{l.value=!1,i.value=0,s.value=0};B(()=>m.data,c),B(()=>m.config,c);const i=y(0),s=y(0),S=y(null);function h(){setTimeout(()=>{const g=Date.now();let t=0,o=s.value,a=null;for(;Date.now()-g<45;){const f=new n(m.config,m.data),b=f.getScore();b>o&&(o=b,a=f),t+=1}i.value+=t,a&&(s.value=o,S.value=a,u("best",a.toData())),l.value&&h()})}class n{constructor(t,o){R(this,"sessions",[]);R(this,"dataMap",new Map);this.newPeopleWeight=t.newPeopleWeight;for(let a=0;a<o.length;a+=1)this.dataMap.set(o[a],a);for(;this.sessions.length<t.sessions;)this.sessions.push(new v(this.sessions.length+1,t.groups,t.fields,o))}toData(){return this.sessions.map(t=>t.toData())}getScore(){return this.sessions.reduce((t,o)=>t+o.getScore(this),this.scoreNewPeople())}scoreNewPeople(){let t=new Map;for(const o of this.sessions)for(const a of o.groups){const f=a.members.length;for(let b=0;b<f;b+=1){const w=this.dataMap.get(a.members[b]);for(let k=b+1;k<f;k+=1){const T=this.dataMap.get(a.members[k]),A=w<T?`${w} ${T}`:`${T} ${w}`;t.set(A,!0)}}}return t.size*this.newPeopleWeight}}class v{constructor(t,o,a,f){R(this,"groups",[]);this.sessionNumber=t,this.fields=a;const b=[...f];for(;this.groups.length<o;)this.groups.push(this.makeGroup(b,o-this.groups.length))}toData(){return this.groups.map(t=>t.toData())}makeGroup(t,o){let a=t.length/o;const f=new x(this.groups.length+1,this.fields);for(;a>0;){const b=Math.floor(Math.random()*t.length),w=t.splice(b,1);f.addMember(w[0]),a-=1}return f}getScore(){return this.groups.reduce((t,o)=>t+o.getScore(),0)}}class x{constructor(t,o){R(this,"members",[]);this.groupNumber=t,this.fields=o}toData(){return this.members.map(t=>t)}addMember(t){this.members.push(t)}getScore(){return Object.values(this.fields).reduce((t,o)=>t+this.scoreField(o),0)}scoreField(t){if(t.weight===0||t.mapping==="IGNORE")return 0;switch(t.mapping){case"MATCH":return this.scoreFieldMatching(t);case"DIST":return this.scoreFieldDistance(t,!1);case"DIST_SQ":return this.scoreFieldDistance(t,!0)}return 0}scoreFieldMatching(t){let o=0;const a=this.members.length;for(let f=0;f<a;f+=1){const b=this.members[f];for(let w=f+1;w<a;w+=1){const k=this.members[w];b[t.name]===k[t.name]&&(o+=1)}}return o*t.weight}scoreFieldDistance(t,o){let a=0,f=0;for(const k of this.members){const T=k[t.name];typeof T=="number"&&(a+=T,f+=1)}const b=a/f;let w=0;for(const k of this.members){const T=k[t.name];if(typeof T=="number"){const I=Math.abs(b-T)*t.weight;if(o){const U=I<0?-1:1;w+=I*I*U}else w+=I}}return w}}return(g,t)=>(p(),d(M,null,[t[4]||(t[4]=e("h2",null,"Step 3: Configuration",-1)),l.value?(p(),d("button",{key:0,onClick:t[0]||(t[0]=o=>l.value=!1)},"Stop Searching")):O("v-if",!0),l.value?O("v-if",!0):(p(),d("button",{key:1,onClick:t[1]||(t[1]=o=>{l.value=!0,h()})},"Start Searching")),e("table",null,[e("tr",null,[t[2]||(t[2]=e("th",null,"Attempts",-1)),e("td",null,C(i.value),1)]),e("tr",null,[t[3]||(t[3]=e("th",null,"Score",-1)),e("td",null,C(s.value),1)])])],64))}}),J=["onUpdate:modelValue"],K=["onUpdate:modelValue"],X=V({__name:"GroupOMaticStep2",props:{data:{}},emits:["config"],setup(m,{emit:r}){const u=r,l=y(1),c=y(1),i=y(1),s=y(S(m.data));B(()=>m.data,()=>s.value=S(m.data));function S(h){return h?Object.keys(h[0]).map(n=>({name:n,mapping:"IGNORE",weight:1})):[]}return(h,n)=>{var v,x;return p(),d(M,null,[n[14]||(n[14]=e("h2",null,"Step 2: Configuration",-1)),e("table",null,[e("tr",null,[n[4]||(n[4]=e("th",null,"Number of Sessions",-1)),e("td",null,[F(e("input",{type:"number","onUpdate:modelValue":n[0]||(n[0]=g=>l.value=g)},null,512),[[P,l.value]])]),n[5]||(n[5]=e("td",null,"How many times participants will meet as groups",-1))]),e("tr",null,[n[6]||(n[6]=e("th",null,"Number of Groups",-1)),e("td",null,[F(e("input",{type:"number","onUpdate:modelValue":n[1]||(n[1]=g=>c.value=g)},null,512),[[P,c.value]])]),n[7]||(n[7]=e("td",null," Total number of groups per session (participants will be divided evenly) ",-1))]),e("tr",null,[n[8]||(n[8]=e("th",null,"Weight for new people in a group",-1)),e("td",null,[F(e("input",{type:"number","onUpdate:modelValue":n[2]||(n[2]=g=>i.value=g)},null,512),[[P,i.value]])]),n[9]||(n[9]=e("td",null," Number of points to award for each new pairing of people in the groups. 0 means this is not important, 1 is typical, 100 would be quite extreme. ",-1))])]),n[15]||(n[15]=e("hr",null,null,-1)),e("table",null,[e("tr",null,[n[10]||(n[10]=e("th",null,"Number of Participants",-1)),e("td",null,C((v=h.data)==null?void 0:v.length),1)]),e("tr",null,[n[11]||(n[11]=e("th",null,"Participants per Group",-1)),e("td",null,C(((x=h.data)==null?void 0:x.length)/c.value),1)])]),n[16]||(n[16]=e("hr",null,null,-1)),e("table",null,[n[13]||(n[13]=e("tr",null,[e("th",null,"Field Name"),e("th",null,"Mapping"),e("th",null,"Weight")],-1)),(p(!0),d(M,null,N(s.value,g=>(p(),d("tr",null,[e("td",null,C(g.name),1),e("td",null,[F(e("select",{"onUpdate:modelValue":t=>g.mapping=t},[...n[12]||(n[12]=[e("option",{value:"IGNORE"},"Ignore",-1),e("option",{value:"MATCH"},"Add points for each match",-1),e("option",{value:"DIST"}," Add points times distance from mean ",-1),e("option",{value:"DIST_SQ"}," Add points times the squared distance from mean ",-1)])],8,J),[[q,g.mapping]])]),e("td",null,[F(e("input",{type:"number","onUpdate:modelValue":t=>g.weight=t},null,8,K),[[P,g.weight]])])]))),256))]),e("button",{onClick:n[3]||(n[3]=g=>u("config",{sessions:l.value,groups:c.value,newPeopleWeight:i.value,fields:s.value}))}," Use These Settings "),n[17]||(n[17]=e("p",null," When matching values in a group, the weight is applied for each match. So, if your group had A B B C C, it would get the score of (weight * 2) because of the B+B and C+C pairs. If you want items to not match, use a negative weight. ",-1)),n[18]||(n[18]=e("p",null," The distance from the mean numerical value is a sum of each member of the group and how far it is off from the mean. This sum is then scored as (weight * sum). This score can also be squared on a per-member basis, which provides tighter grouping. The distance calculations will skip comparisons against empty values. ",-1)),n[19]||(n[19]=e("p",null," Positive weights mean you want that type of mapping to happen. Negative weights will try to avoid that type of mapping. Empty or non-weighted items are skipped. ",-1))],64)}}}),Y=V({__name:"GroupOMaticStep1",emits:["fileRead","fileReadError"],setup(m,{emit:r}){const u=r,l=i=>{const s=i.dataTransfer.files;if(!s[0]){alert("No files were dragged to the page. Please try again.");return}c(s[0])},c=i=>{const s=new FileReader;s.onabort=function(){alert("Read aborted"),u("fileReadError")},s.onerror=function(){alert("Read error"),u("fileReadError")},s.onload=function(){const S=s.result.replace(/\r/g,`
`).replace(/\n\n+/g,`
`).replace(/$/,`
`).replace(/\n(( *,)+\n)+/g,`
`).replace(/\n+$/,""),h=Papa.parse(S,{dynamicTyping:!0,header:!0});if(h.errors.length){alert("Error parsing CSV file"),console.log(h.errors),u("fileReadError");return}u("fileRead",h.data)},s.readAsText(i)};return(i,s)=>(p(),d(M,null,[s[4]||(s[4]=e("h2",null,"Step 1: Load CSV",-1)),e("div",{class:"target",onDragenter:s[0]||(s[0]=E(()=>{},["stop","prevent"])),onDragover:s[1]||(s[1]=E(()=>{},["stop","prevent"])),onDrop:s[2]||(s[2]=E(S=>l(S),["stop","prevent"]))},[...s[3]||(s[3]=[e("div",null,"Upload a CSV file with a list of names to get started.",-1),e("div",null," The CSV file will be scanned for fields that you can use to make groupings. ",-1)])],32)],64))}}),Z=z(Y,[["__scopeId","data-v-b7c7a903"]]),ne=V({__name:"GroupOMatic",setup(m){let r=y(null),u=y(null),l=y(null);return(c,i)=>{const s=Z,S=X,h=Q,n=L;return p(),d(M,null,[i[4]||(i[4]=e("h1",null,"Group-O-Matic",-1)),i[5]||(i[5]=e("p",null," Take a list of names and create groups of a specified size. Repeats the process for a series of groupings so you can get maximum interaction with new people at each session. ",-1)),H(s,{onFileRead:i[0]||(i[0]=v=>{D(r)?r.value=v:r=v,D(u)?u.value=null:u=null,D(l)?l.value=null:l=null}),onFileReadError:i[1]||(i[1]=v=>{D(r)?r.value=null:r=null,D(u)?u.value=null:u=null,D(l)?l.value=null:l=null})}),G(r)?(p(),$(S,{key:0,data:G(r),onConfig:i[2]||(i[2]=v=>{D(u)?u.value=v:u=v,D(l)?l.value=null:l=null})},null,8,["data"])):O("v-if",!0),G(r)&&G(u)?(p(),$(h,{key:1,data:G(r),config:G(u),onBest:i[3]||(i[3]=v=>{D(l)?l.value=v:l=v,console.log(G(l))})},null,8,["data","config"])):O("v-if",!0),G(l)?(p(),$(n,{key:2,best:G(l)},null,8,["best"])):O("v-if",!0)],64)}}});export{ne as _};
